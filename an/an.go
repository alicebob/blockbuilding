// analyze logs generated by fun.
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"net/url"
	"os"
	"sort"
)

type DomainStat struct {
	Domain     string
	XMLHTTP    int
	Image      int
	StyleSheet int
	Script     int
	Other      int
	SrcDomains map[string]int
}

func main() {
	// resource domain, where is it called from, and how often.
	stat := map[string]DomainStat{}

	f := csv.NewReader(os.Stdin)
	for true {
		r, err := f.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			panic(err)
		}
		// format: time, action, type, URL, tab URL
		action, typ := r[1], r[2]
		if action != "allow" {
			continue
		}
		rURL, err := url.Parse(r[3])
		if err != nil {
			panic(err)
		}
		tURL, err := url.Parse(r[4])
		if err != nil {
			panic(err)
		}
		if rURL.Host == tURL.Host {
			// same domain. Not interesting.
			continue
		}

		d := stat[rURL.Host]
		d.Domain = rURL.Host
		switch typ {
		case "xmlhttprequest":
			d.XMLHTTP++
		case "image":
			d.Image++
		case "stylesheet":
			d.StyleSheet++
		case "script":
			d.Script++
		case "other":
			d.Other++
		case "sub_frame":
			//
		default:
			panic(typ)
		}
		if d.SrcDomains == nil {
			d.SrcDomains = map[string]int{}
		}
		d.SrcDomains[tURL.Host]++
		stat[rURL.Host] = d
		// fmt.Printf("%s: %s called from %s\n", typ, rURL.Host, tURL.Host)
	}

	st := make([]DomainStat, 0, len(stat))
	for _, s := range stat {
		st = append(st, s)
	}
	sort.Sort(sort.Reverse(BySrcCount(st)))
	for _, s := range st {
		fmt.Printf("%s: %v\n", s.Domain, s)
	}
}

type BySrcCount []DomainStat

func (s BySrcCount) Len() int      { return len(s) }
func (s BySrcCount) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
func (s BySrcCount) Less(i, j int) bool {
	if len(s[i].SrcDomains) != len(s[j].SrcDomains) {
		return len(s[i].SrcDomains) < len(s[j].SrcDomains)
	}
	return s[i].Image < s[j].Image
}
