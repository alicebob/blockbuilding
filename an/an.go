// analyze logs generated by fun.
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"net/url"
	"os"
	"sort"

	"golang.org/x/net/publicsuffix"
)

type DomainStat struct {
	Domain     string
	XMLHTTP    int
	Image      int
	StyleSheet int
	Script     int
	SubFrame   int
	Other      int
	SrcDomains map[string]int
}

func main() {
	// resource domain, where is it called from, and how often.
	stat := map[string]DomainStat{}

	f := csv.NewReader(os.Stdin)
	for true {
		r, err := f.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			panic(err)
		}
		// format: time, action, type, URL, tab URL
		action, typ := r[1], r[2]
		if action != "allow" {
			continue
		}
		rURL, err := url.Parse(r[3])
		if err != nil {
			panic(err)
		}
		if rURL.Scheme == "chrome-extension" {
			continue
		}

		tURL, err := url.Parse(r[4])
		if err != nil {
			panic(err)
		}
		if rURL.Host == tURL.Host {
			// same domain. Not interesting.
			continue
		}

		d := stat[rURL.Host]
		d.Domain = rURL.Host
		switch typ {
		case "xmlhttprequest":
			d.XMLHTTP++
		case "image":
			d.Image++
		case "stylesheet":
			d.StyleSheet++
		case "script":
			d.Script++
		case "sub_frame":
			d.SubFrame++
		case "other":
			d.Other++
		default:
			panic(typ)
		}
		if d.SrcDomains == nil {
			d.SrcDomains = map[string]int{}
		}
		d.SrcDomains[tURL.Host]++
		stat[rURL.Host] = d
		// fmt.Printf("%s: %s called from %s\n", typ, rURL.Host, tURL.Host)
	}

	st := make([]DomainStat, 0, len(stat))
	for _, s := range stat {
		st = append(st, s)
	}
	sort.Sort(sort.Reverse(BySrcCount(st)))
	for _, s := range st {
		fmt.Printf("%s", s.Domain)
		eff, err := publicsuffix.EffectiveTLDPlusOne(s.Domain)
		if err != nil {
			panic(err)
		}
		fmt.Printf(" - eff: %s ", eff)
		fmt.Printf("\n    ")
		fmt.Printf("domains: %v ", s.SrcDomains)
		fmt.Printf("\n    ")
		if s.XMLHTTP > 0 {
			fmt.Printf(", XMLHTTP: %d", s.XMLHTTP)
		}
		if s.Image > 0 {
			fmt.Printf(", Image: %d", s.Image)
		}
		if s.StyleSheet > 0 {
			fmt.Printf(", StyleSheet: %d", s.StyleSheet)
		}
		if s.Script > 0 {
			fmt.Printf(", Script: %d", s.Script)
		}
		if s.SubFrame > 0 {
			fmt.Printf(", SubFrame: %d", s.SubFrame)
		}
		if s.Other > 0 {
			fmt.Printf(", Other: %d", s.Other)
		}
		fmt.Printf("\n")
	}
}

type BySrcCount []DomainStat

func (s BySrcCount) Len() int      { return len(s) }
func (s BySrcCount) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
func (s BySrcCount) Less(i, j int) bool {
	if len(s[i].SrcDomains) != len(s[j].SrcDomains) {
		return len(s[i].SrcDomains) < len(s[j].SrcDomains)
	}
	return s[i].Image < s[j].Image
}
